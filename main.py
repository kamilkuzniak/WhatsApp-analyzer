from person import Person
import pandas as pd
import numpy as np
import time
from datetime import datetime
from time import mktime
import seaborn as sns
import matplotlib.pyplot as plt


def chat_fix(messages, timestamps):
    # Fixing the messages list from errors resulting from the multiline messages in the original file and creating a dates list
    for i in range(len(messages)):
        try:
            timestamps.append(time.strptime(messages[i].split('-')[0].split(',')[0] + messages[i].split('-')[0].split(',')[1], '%m/%d/%y %H:%M '))
        except:
            num = 1
            while True:
                if messages[i - num] != 'NaN':
                    messages[i - num] += (' ' + messages[i])
                    messages[i] = 'NaN'
                    break
                else:
                    num += 1


def remove_nan(messages):
    while True:
        try:
            messages.remove('NaN')
        except ValueError:
            break

# Reading from the file generated by WhatsApp
with open('WhatsApp Chat with Sara.txt', 'r') as chat:
    messages = chat.readlines()

people = []
names = []
person = []
timestamps = []
content = []
dates = []
hours = []

chat_fix(messages, timestamps)

remove_nan(messages)

for message in messages:
    try:
        content.append(message.split('-')[1].split(':', maxsplit=1)[1].replace(' ', '', 1))
        person.append(message.split('-')[1].split(':', maxsplit=1)[0].replace(' ', '', 1))
    except:
        content.append(message.split('-')[1].replace(' ', '', 1))
        person.append('-')

for timestamp in timestamps:
    dates.append(datetime.fromtimestamp(mktime(timestamp)).date())
    hours.append(datetime.fromtimestamp(mktime(timestamp)).time())

chat_data = pd.DataFrame({'Date': dates, 'Time': hours, 'Content': content, 'Person': person})
#chat_data = pd.DataFrame(list(zip(dates, hours, content, person)), columns = ['Date', 'Time', 'Content', 'Person'])

names = np.delete(chat_data['Person'].unique(), np.where(chat_data['Person'].unique() == '-'))

#byMonth = chat_data.groupby(chat_data['Date'].apply(lambda dt: dt.month)).count()
#byMonthPlot = sns.countplot(x=chat_data['Date'][1:].apply(lambda dt: dt.month), data=chat_data, hue=chat_data[chat_data['Person'] != '-']['Person'])
byMonthPlot = sns.countplot(x=chat_data[chat_data['Date'].apply(lambda dt: dt.year) == 2019]['Date'][1:].apply(lambda dt: dt.month), data=chat_data, hue=chat_data[chat_data['Person'] != '-']['Person'])
plt.xlabel('Month')
plt.show()
figure = byMonthPlot.get_figure()
figure.savefig('byMonthPlot.png')

#TO DO
#This exists: df['timeStamp'] = pd.to_datetime(df['timeStamp'])
#improve printing of the most common words
#Graphs for monthly number of messages
#Monthly word averages
#Monthly word count
#Most common time of chatting, most common day, month as well

# This loop creates a person object for each person participating in the chat
for name in names:
    people.append(Person(name))

for person in people:
    person.count_messages(chat_data)
    person.count_words(chat_data)
    person.calculate_average()
    person.most_common_words(chat_data)
    person.count_media(chat_data)
    print(person)

# print('Kamil sent ' + str(round((1 - kamil_msg/sara_msg)*100)) + '% less messages than Sara')
# print('Kamil sent ' + str(round((1 - kamil_words / sara_words) * 100)) + '% less words than Sara')

# if __name__ == '__main__':
